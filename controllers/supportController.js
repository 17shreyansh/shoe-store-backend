const Ticket = require('../models/Support');
const User = require('../models/User'); // Assuming User model is needed for other functions
const asyncHandler = require('express-async-handler');

// @desc    Create new ticket
// @route   POST /api/tickets
// @access  Private
const createTicket = asyncHandler(async (req, res) => {
  const { title, description, category, priority } = req.body;

  if (!title || !description || !category) {
    res.status(400);
    throw new Error('Please provide title, description, and category');
  }

  // Create a new Ticket instance first
  const newTicket = new Ticket({
    title,
    description,
    category,
    priority: priority || 'Medium',
    user: req.user._id
    // Do NOT include ticketId here; it will be generated by the pre-save hook
  });

  // Now, save the ticket. The pre-save hook will run before validation.
  const ticket = await newTicket.save();

  const populatedTicket = await Ticket.findById(ticket._id)
    .populate('user', 'name email')
    .populate('assignedTo', 'name email');

  res.status(201).json({
    success: true,
    data: populatedTicket
  });
});

// @desc    Get user tickets
// @route   GET /api/tickets
// @access  Private
const getUserTickets = asyncHandler(async (req, res) => {
  const page = parseInt(req.query.page) || 1;
  const limit = parseInt(req.query.limit) || 10;
  const status = req.query.status;
  const category = req.query.category;

  const query = { user: req.user._id };

  if (status) query.status = status;
  if (category) query.category = category;

  const skip = (page - 1) * limit;

  const tickets = await Ticket.find(query)
    .populate('user', 'name email')
    .populate('assignedTo', 'name email')
    .populate('messages.sender', 'name email')
    .sort({ createdAt: -1 })
    .skip(skip)
    .limit(limit);

  const total = await Ticket.countDocuments(query);

  res.json({
    success: true,
    data: tickets,
    pagination: {
      page,
      pages: Math.ceil(total / limit),
      total,
      limit
    }
  });
});

// @desc    Get all tickets (Admin)
// @route   GET /api/tickets/admin
// @access  Private/Admin
const getAllTickets = asyncHandler(async (req, res) => {
  const page = parseInt(req.query.page) || 1;
  const limit = parseInt(req.query.limit) || 10;
  const status = req.query.status;
  const priority = req.query.priority;
  const category = req.query.category;
  const search = req.query.search;

  const query = {};

  if (status) query.status = status;
  if (priority) query.priority = priority;
  if (category) query.category = category;

  if (search) {
    query.$or = [
      { ticketId: { $regex: search, $options: 'i' } },
      { title: { $regex: search, $options: 'i' } },
      { description: { $regex: search, $options: 'i' } }
    ];
  }

  const skip = (page - 1) * limit;

  const tickets = await Ticket.find(query)
    .populate('user', 'name email')
    .populate('assignedTo', 'name email')
    .populate('messages.sender', 'name email')
    .sort({ createdAt: -1 })
    .skip(skip)
    .limit(limit);

  const total = await Ticket.countDocuments(query);

  // Get ticket statistics
  const stats = await Ticket.aggregate([
    {
      $group: {
        _id: '$status',
        count: { $sum: 1 }
      }
    }
  ]);

  const statusStats = {
    Open: 0,
    'In Progress': 0,
    Resolved: 0,
    Closed: 0
  };

  stats.forEach(stat => {
    statusStats[stat._id] = stat.count;
  });

  res.json({
    success: true,
    data: tickets,
    stats: statusStats,
    pagination: {
      page,
      pages: Math.ceil(total / limit),
      total,
      limit
    }
  });
});

// @desc    Get single ticket
// @route   GET /api/tickets/:id
// @access  Private
const getTicket = asyncHandler(async (req, res) => {
  const ticket = await Ticket.findById(req.params.id)
    .populate('user', 'name email')
    .populate('assignedTo', 'name email')
    .populate('messages.sender', 'name email');

  if (!ticket) {
    res.status(404);
    throw new Error('Ticket not found');
  }

  // Check if user owns ticket or is admin
  if (ticket.user._id.toString() !== req.user._id.toString() && !req.user.isAdmin) {
    res.status(403);
    throw new Error('Not authorized to view this ticket');
  }

  res.json({
    success: true,
    data: ticket
  });
});

// @desc    Update ticket
// @route   PUT /api/tickets/:id
// @access  Private
const updateTicket = asyncHandler(async (req, res) => {
  const ticket = await Ticket.findById(req.params.id);

  if (!ticket) {
    res.status(404);
    throw new Error('Ticket not found');
  }

  // Check if user owns ticket or is admin
  if (ticket.user.toString() !== req.user._id.toString() && !req.user.isAdmin) {
    res.status(403);
    throw new Error('Not authorized to update this ticket');
  }

  const updatedTicket = await Ticket.findByIdAndUpdate(
    req.params.id,
    req.body,
    { new: true, runValidators: true }
  ).populate('user', 'name email')
   .populate('assignedTo', 'name email')
   .populate('messages.sender', 'name email');

  res.json({
    success: true,
    data: updatedTicket
  });
});

// @desc    Add message to ticket
// @route   POST /api/tickets/:id/messages
// @access  Private
const addMessage = asyncHandler(async (req, res) => {
  const { message } = req.body;

  if (!message) {
    res.status(400);
    throw new Error('Message is required');
  }

  const ticket = await Ticket.findById(req.params.id);

  if (!ticket) {
    res.status(404);
    throw new Error('Ticket not found');
  }

  // Check if user owns ticket or is admin
  if (ticket.user.toString() !== req.user._id.toString() && !req.user.isAdmin) {
    res.status(403);
    throw new Error('Not authorized to add message to this ticket');
  }

  const newMessage = {
    sender: req.user._id,
    message,
    isAdminReply: req.user.isAdmin
  };

  ticket.messages.push(newMessage);

  // Update status if admin replies
  if (req.user.isAdmin && ticket.status === 'Open') {
    ticket.status = 'In Progress';
  }

  await ticket.save();

  const updatedTicket = await Ticket.findById(req.params.id)
    .populate('user', 'name email')
    .populate('assignedTo', 'name email')
    .populate('messages.sender', 'name email');

  res.json({
    success: true,
    data: updatedTicket
  });
});

// @desc    Assign ticket (Admin)
// @route   PUT /api/tickets/:id/assign
// @access  Private/Admin
const assignTicket = asyncHandler(async (req, res) => {
  const { assignedTo } = req.body;

  const ticket = await Ticket.findById(req.params.id);

  if (!ticket) {
    res.status(404);
    throw new Error('Ticket not found');
  }

  // Verify assigned user exists and is admin
  if (assignedTo) {
    const assignedUser = await User.findById(assignedTo);
    if (!assignedUser || !assignedUser.isAdmin) {
      res.status(400);
      throw new Error('Invalid assigned user');
    }
  }

  ticket.assignedTo = assignedTo;
  ticket.status = assignedTo ? 'In Progress' : 'Open';

  await ticket.save();

  const updatedTicket = await Ticket.findById(req.params.id)
    .populate('user', 'name email')
    .populate('assignedTo', 'name email')
    .populate('messages.sender', 'name email');

  res.json({
    success: true,
    data: updatedTicket
  });
});

// @desc    Close ticket with rating
// @route   PUT /api/tickets/:id/close
// @access  Private
const closeTicket = asyncHandler(async (req, res) => {
  const { rating, feedback } = req.body;

  const ticket = await Ticket.findById(req.params.id);

  if (!ticket) {
    res.status(404);
    throw new Error('Ticket not found');
  }

  // Check if user owns ticket
  if (ticket.user.toString() !== req.user._id.toString()) {
    res.status(403);
    throw new Error('Not authorized to close this ticket');
  }

  ticket.status = 'Closed';
  if (rating) ticket.rating = rating;
  if (feedback) ticket.feedback = feedback;

  await ticket.save();

  const updatedTicket = await Ticket.findById(req.params.id)
    .populate('user', 'name email')
    .populate('assignedTo', 'name email')
    .populate('messages.sender', 'name email');

  res.json({
    success: true,
    data: updatedTicket
  });
});

// @desc    Delete ticket
// @route   DELETE /api/tickets/:id
// @access  Private/Admin
const deleteTicket = asyncHandler(async (req, res) => {
  const ticket = await Ticket.findById(req.params.id);

  if (!ticket) {
    res.status(404);
    throw new Error('Ticket not found');
  }

  await ticket.deleteOne();

  res.json({
    success: true,
    message: 'Ticket deleted successfully'
  });
});

module.exports = {
  createTicket,
  getUserTickets,
  getAllTickets,
  getTicket,
  updateTicket,
  addMessage,
  assignTicket,
  closeTicket,
  deleteTicket
};
